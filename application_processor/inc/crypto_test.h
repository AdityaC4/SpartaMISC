#ifndef ECTF_CRYPTO_TEST_H
#define ECTF_CRYPTO_TEST_H

#include "host_messaging.h"
#include "ectf_keys.h"

#include "wolfssl/wolfcrypt/ecc.h"
#include "wolfssl/wolfcrypt/hash.h"
#include "wolfssl/wolfcrypt/random.h"
#include "wolfssl/wolfcrypt/asn_public.h"
#include "wolfssl/wolfcrypt/integer.h"

// Test values for simulated handshake
#define COMP_PRIVKEY_DER { 0x30,0x81,0x87,0x2,0x1,0x0,0x30,0x13,0x6,0x7,0x2a,0x86,0x48,0xce,0x3d,0x2,0x1,0x6,0x8,0x2a,0x86,0x48,0xce,0x3d,0x3,0x1,0x7,0x4,0x6d,0x30,0x6b,0x2,0x1,0x1,0x4,0x20,0x5d,0x58,0xef,0x39,0x45,0x85,0x79,0x80,0xe3,0x6a,0xa6,0x4c,0x83,0xb7,0x48,0x5e,0xe,0x39,0x49,0xef,0xe4,0x38,0xa7,0x82,0xed,0x33,0x15,0xa2,0xcc,0xe4,0xd1,0x69,0xa1,0x44,0x3,0x42,0x0,0x4,0x70,0xcb,0xf,0xb2,0x85,0x87,0xd5,0x54,0x59,0x3a,0x4f,0x1,0xee,0x4a,0xe8,0x55,0x2c,0x4b,0x54,0x1d,0x86,0x35,0x89,0x6f,0x4d,0x6a,0xe2,0x40,0xa5,0xe2,0xe,0x3d,0xb1,0x15,0x67,0x4d,0xd1,0xca,0xce,0xf0,0x13,0xa5,0x36,0xa8,0xd3,0x2f,0x2e,0xbe,0x0,0x9c,0xba,0xad,0x33,0x47,0x9c,0x12,0x1b,0x6e,0x81,0xb,0x55,0xe6,0x9a,0x69 }  
#define COMP_CERT_SIGNATURE { 0x30,0x46,0x2,0x21,0x0,0xd0,0xc2,0xb6,0x7a,0xb2,0x77,0xa8,0xa9,0xf9,0x9d,0xcf,0xe7,0x38,0x59,0xaa,0xf2,0x52,0x5,0x58,0x4d,0xfa,0xf5,0xb1,0x8b,0xc8,0xae,0xfd,0x47,0x61,0x62,0x58,0xf8,0x2,0x21,0x0,0xb6,0xed,0x6b,0xae,0x4a,0x55,0x4,0xb,0x4e,0x47,0xc4,0x9f,0x6f,0xfa,0x45,0x73,0x65,0x48,0x62,0x78,0x59,0x96,0x85,0xfc,0x81,0x4,0x2f,0xc4,0xd6,0x61,0xee,0x61 } 
#define COMPONENT_ID 286331173

#define AP_CERT_SIGNATURE	CERT_SIGNATURE

#define ECC_CURVE			ECC_SECP256R1
#define ECC_KEY_LEN			32

#define COMPR_KEY_SIZE		33
#define COMPR_KEY_BUFSIZE	36 	// To avoid struct padding issues, just in case

#define PUBKEY_BUF_LEN		ECC_BUFSIZE
#define PUBKEY_LEN 			ECC_MAXSIZE+1

#define POINT_SIZE			32
#define CERT_DATA_SIZE		2 * POINT_SIZE + 4
#define ECC_SIG_SIZE 		72

#define SHARED_KEY_SIZE		32

#define AP_TAG				0xffffffff

// All of these should be smaller than MAX_I2C_MESSAGE_LEN-1

typedef struct cert_data {
	byte pubkey_x[32];
	byte pubkey_y[32];
	word32 tag;
} cert_data;

typedef struct hello {
	// Compressed ANSI X9.63 keys
	byte pubkey[COMPR_KEY_BUFSIZE];
	byte dh_pubkey[COMPR_KEY_BUFSIZE];
} hello;

typedef struct signed_hello {
	hello hi;
	byte hello_sig[ECC_SIG_SIZE];
	word32 hello_sig_size;
} signed_hello;

// Hellos shared between AP and component with certificate and DH key info
typedef struct signed_hello_with_cert {
	signed_hello sh;

	byte cert_sig[ECC_SIG_SIZE];
	word32 cert_sig_size;
} signed_hello_with_cert;

// Response from the Component to the AP: contains the same data except with a signed challenge (DH pubkey)
// typedef struct signed_hello_with_cert_and_chal {
// 	signed_hello_with_cert shc; 

// 	byte chal_sig[ECC_SIG_SIZE];
// 	word32 chal_sig_size;
// } signed_hello_with_cert_and_chal;

// Sent back by the AP to the Component as AP's challenge-response to finish the verification
typedef struct signed_chal {
	byte chal_sig[ECC_SIG_SIZE];
	word32 chal_sig_size;
} signed_chal;

int make_ecc_key(ecc_key* key, WC_RNG* rng);

int load_ap_private_key(ecc_key *key);

int load_comp_private_key(ecc_key *key);

int load_host_public_key(ecc_key *key);

int construct_device_cert_data(cert_data *cert, ecc_key *device_key,
                               word32 dev_id);

int sign_data(const byte *data, word32 data_size, byte *sig, word32 *sig_size,
              ecc_key *key, WC_RNG *rng);

int verify_data_signature(const byte *data, word32 data_size, const byte *sig,
                          word32 sig_size, ecc_key *key);

int create_hello(signed_hello_with_cert *msg, int is_ap, ecc_key *self_dh_key);

int verify_hello(signed_hello_with_cert *msg, byte *shared_key,
                 word32 *shared_key_sz, ecc_key *self_dh_key,
                 word32 sender_device_id, // Component ID or AP tag
                 ecc_key *sender_pubkey);

int simulate_handshake();

#endif
